#!/usr/bin/env node
var child_process = require('child_process');
var fs = require('fs');
var path = require('path');

var coffee = require('coffee-script');
var coffeeify = require('caching-coffeeify');
var convert = require('convert-source-map');
var glob = require('glob');
var q = require('kew');
var mkdirp = require('mkdirp');
var sourceMap = require('source-map');
var through = require('through');
var UglifyJS = require('uglify-js');
var UglifyCSS = require('uglifycss');
var umd = require('umd');
var umd = require('umd');

var annotator = require('../');
var browserify = annotator.browserify;
var include = annotator.include;

var SourceMapConsumer = sourceMap.SourceMapConsumer;
var SourceMapGenerator = sourceMap.SourceMapGenerator;
var SourceNode = sourceMap.SourceNode;


// A global map of libraries to their hashed contents.
// As browserify processes files, we write them to the output directory.
// Since many bundles share files, we use this to write them only once as
// they change.
var libs = {};


// Uglify emits ugly warnings for source maps it can't resolve.
// It cannot map our license preamble or the browserify wrappers.
// It feels ugly, but let's just disable these.
UglifyJS.AST_Node.warn_function = null;


// Uglify a source with the supplied source map generator.
// Returns {code::String, map::SourceMapGenerator}
function uglify(src, srcMap) {
  var comment = '//@ sourceMappingURL=';
  var inSrcMap = convert.fromJSON(srcMap.toString());
  var filename = inSrcMap.getProperty('file').replace('.js', '.min.js');

  // Parse the result with UglifyJS
  var ast = UglifyJS.parse(src, {filename: inSrcMap.getProperty('file')});

  // Set up the UglifyJS compression pipeline
  srcMap = UglifyJS.SourceMap({
    file: path.basename(filename),
    orig: srcMap.toString(),
    root: inSrcMap.getProperty('sourceRoot')
  });
  src = UglifyJS.OutputStream({
    comments: /Copyright/g,
    source_map: srcMap
  });

  // Perform the minification
  ast.figure_out_scope();
  ast = ast.transform(UglifyJS.Compressor());
  ast.figure_out_scope();
  ast.compute_char_frequency();
  ast.mangle_names();
  ast.print(src);

  // Read the source and source map from the uglify pipeline
  src = src.get() + '\n' + comment + filename + '.map';
  srcMap = convert.fromJSON(srcMap.toString());

  // Add all the sources and inline them into the source map
  // UglifyJS drops all but the first source file
  srcMap.setProperty('sources', inSrcMap.getProperty('sources'));
  srcMap.setProperty('sourcesContent', inSrcMap.getProperty('sourcesContent'));

  srcMap = SourceMapGenerator.fromSourceMap(
    new SourceMapConsumer(srcMap.toObject())
  );

  return {code: src, map: srcMap};
}


// The core Annotator library
exports.annotator = function (browserify) {
  return browserify({extensions: ['.coffee']})
    .external('jquery')
    .require('./src/annotator', {expose: 'annotator', entry: true})
    .transform(coffeeify)
  ;
};


// The plugin bundles
exports.plugin = function (browserify, p) {
  var name = path.basename(p).replace('.coffee', '');
  var expose = ['annotator', 'plugin', name].join('-')
    .replace('.js', '')
  ;

  return include(browserify, {extensions: ['.coffee']})
    .require(p, {expose: expose})
    .transform(coffeeify)
  ;
};


// Test files
exports.test = function (browserify, t) {
  return browserify({entries: [t], extensions: ['.coffee']})
    .external('annotator')
    .external('helpers')
    .external('jquery')
    .transform(coffeeify)
  ;
};


// Package the bundles when called as the main script
if (require.main === module) {
  var depsOnly = false;
  var preamble = null;
  var promises = {annotator: null, plugin: {}, fin: q.defer()};
  var targets = Array.prototype.slice.call(process.argv, 2);

  child_process.exec('./tools/preamble', function (err, preambleSrc) {
    if (err) throw (err);
    preamble = coffee.compile(preambleSrc, {bare: true}).trim() + '\n';
    next()
  });

  promises.fin.fail(function (err) {
    process.exit(64);
  });

  function mapcat(nodes) {
    return nodes.reduce(function (full, node) {
      full.add(node);
      return full;
    });
  }

  function next() {
    target = targets.shift();

    switch (target) {
    case '-c':
      css();
      break;
    case '-d':
      if (promises.annotator || Object.keys(promises.plugin).length) {
        console.error('Flag `-d` must come before any targets.');
        process.exit(64);
      }
      depsOnly = true;
      break;
    case 'annotator':
      if (!promises.annotator) {
        promises.annotator = core()
        promises.annotator
          .then(write.bind(null, 'pkg/annotator.js'))
          .fail(promises.fin.reject.bind(promises.fin))
        ;
      }
      break;
    case '-p':
      target = targets.shift();
      var name = 'pkg/annotator.' + target + '.js';
      if (!promises.plugin[target]) {
        promises.plugin[target] = plugin(target)
          .then(write.bind(null, name))
          .fail(promises.fin.reject.bind(promises.fin))
        ;
      }
      break;
    case '-a':
      if (!promises.annotator) targets.push('annotator');
      glob.sync('./src/plugin/*.coffee').forEach(function (p) {
        var name = p.match(/(\w+).coffee$/)[1];
        targets.push('-p');
        targets.push(name);
      });
      promises.fin.then(function () {
        var pkg = [promises.annotator];
        for (var p in promises.plugin) pkg.push(promises.plugin[p]);
        q.all(pkg).then(mapcat).then(write.bind(null, 'pkg/annotator-full.js'));
      });
      break;
    case undefined:
      return promises.fin.resolve();
    default:
      console.error('Unrecognized target:', target);
      process.exit(64);
    }

    q.fcall(next);
  }

  function write(filename, node) {
    if (depsOnly) return process.stdout.write(node);
    node.prepend(preamble);

    // Output the source with the preamble appended
    var output = node.toStringWithSourceMap({file: filename});
    console.log('Writing', filename);
    fs.writeFileSync(filename, [
      output.code,
      convert.fromJSON(output.map.toString()).toComment()
    ].join('\n'));

    // Compress the source
    var compressed = uglify(output.code, output.map);

    // Write the minified source
    filename = filename.replace('.js', '.min.js');
    console.log('Writing', filename);
    fs.writeFileSync(filename, compressed.code);

    // Write the minified source map
    filename += '.map';
    console.log('Writing', filename);
    fs.writeFileSync(filename, compressed.map.toString());

    return node;
  }

  function css() {
    var src = '';
    var dataURI = child_process.spawn('./tools/data_uri_ify');

    fs.createReadStream('./css/annotator.css').pipe(dataURI.stdin);
    dataURI.stdout.pipe(through(write, end));

    function write (data) { src += data };
    function end() {
      this.queue(null);

      console.log('Writing', 'pkg/annotator.css');
      fs.writeFileSync('pkg/annotator.css', preamble + src);

      src = UglifyCSS.processString(src);
      console.log('Writing', 'pkg/annotator.min.css');
      fs.writeFileSync('pkg/annotator.min.css', preamble + src);
    }
  }

  function core () {
    return pack(exports.annotator(browserify), 'pkg/annotator.js', {
      debug: true,
      standalone: 'Annotator'
    });
  }

  function plugin(name) {
    var source = './src/plugin/' + name + '.coffee';
    var target = 'pkg/annotator.' + path.basename(name) + '.js';
    return pack(exports.plugin(browserify, source), target, {
      debug: true,
      standalone: 'Annotator'
    });
  }

  function pack(b, filename, options) {
    var deps = '';
    var ignore = /(_empty)|(fake_[a-z0-9]+).js$/
    var promise = q.defer();

    if (depsOnly) {
      options.noParse = b._noParse;
      options.resolve = b._resolve.bind(b);
      options.transform = b._transforms;

      b.deps(options).pipe(through(filter, flush));

      function filter(dep) {
        if (dep.id.match(ignore)) return;
        deps += dep.id + '\n';
      }

      function flush() {
        promise.resolve(deps);
      }
    } else {
      b.bundle(options, function (err, result) {
        if (err) return  promise.reject(err);
        var src = convert.removeComments(result).slice(0, -3);
        var srcMap = convert.fromSource(result).toObject();

        // Make the source file paths relative
        srcMap.sources = srcMap.sources.map(function (src) {
          return path.relative('./src', src);
        });
        srcMap.file = path.basename(filename);

        var consumer = new SourceMapConsumer(srcMap);
        var node = SourceNode.fromStringWithSourceMap(src, consumer);
        promise.resolve(node);
      });

      b.on('dep', function (row) {
        if (row.id.match(ignore)) return;
        var filename = path.relative(process.cwd(), row.id)
          .replace('src', 'lib')
          .replace('.coffee', '.js')
        ;
        if (filename == 'main.js') return;
        if (!libs[filename]) {
          libs[filename] = true;
          fs.writeFileSync(filename, row.source);
        }
      });
    }

    return promise;
  }
}
