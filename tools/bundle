#!/usr/bin/env node
var child_process = require('child_process');
var fs = require('fs');
var path = require('path');

var browserify = require('browserify');
var coffee = require('coffee-script');
var coffeeify = require('caching-coffeeify');
var convert = require('convert-source-map');
var glob = require('glob');
var q = require('kew');
var sourceMap = require('source-map');
var UglifyJS = require('uglify-js');
var UglifyCSS = require('uglifycss');
var umd = require('umd');
var watchify = require('watchify');
var umd = require('umd');


var SourceMapConsumer = sourceMap.SourceMapConsumer;
var SourceMapGenerator = sourceMap.SourceMapGenerator;


// Uglify emits ugly warnings for source maps it can't resolve.
// It cannot map our license preamble or the browserify wrappers.
// It feels ugly, but let's just disable these.
UglifyJS.AST_Node.warn_function = null;


// Pack a bundle, prepending the preamble and generating minified versions.
var pack = function (b, filename, preamble, options) {
  b.bundle(options, function (err, result) {
    if (err) throw new Error(err);

    var src = convert.removeComments(result).slice(0,-3);
    var srcMap = new SourceMapGenerator({file: 'generated.js'});
    var inSrcMap = new SourceMapConsumer(convert.fromSource(result).toObject());
    var lineno = preamble.match(/\n/g).length + 1;
    var comment = '//@ sourceMappingURL=';
    var sources = [];
    var sourcesSeen = {};
    var sourcesContent = {};
    var sourcesOrder = 0;

    // Process the mappings accounting for the preamble line(s) and making
    // the source paths relative.
    inSrcMap.eachMapping(function (mapping) {
      var relSource = '/' + path.relative(process.cwd(), mapping.source);
      if (sourcesSeen[relSource] == undefined) {
        var content = inSrcMap.sourceContentFor(mapping.source);
        srcMap.setSourceContent(relSource, content);
        sourcesContent[relSource] = content;
        sourcesSeen[relSource] = sourcesOrder++;
      }
      srcMap.addMapping({
        generated: {
          line: mapping.generatedLine + lineno,  // Account for preamble
          column: mapping.generatedColumn
        },
        original: {
          line: mapping.originalLine,
          column: mapping.originalColumn
        },
        name: mapping.name,
        source: relSource
      });
    });

    // Join the preamble, source and comment
    src = [
      preamble,
      src,
      convert.fromJSON(srcMap.toString()).toComment(),
      ';'
    ].join('\n');

    // Write the bundled output
    console.log('Writing ', 'pkg/' + filename);
    fs.writeFileSync('pkg/' + filename, src);

    // Parse the result with UglifyJS
    try {
      var ast = UglifyJS.parse(src, {filename: filename});
    } catch(e) {
      console.log(src);
    }

    // Switch the filename to .min.js from here
    filename = filename.replace('.js', '.min.js');

    // Set up the UglifyJS compression pipeline
    var minMap = UglifyJS.SourceMap({
      file: filename,
      root: '..',
      orig: convert.fromJSON(srcMap.toString()).toObject()
    });
    var minSrc = UglifyJS.OutputStream({
      comments: /Copyright/,
      source_map: minMap
    });

    // Perform the minification
    ast.figure_out_scope();
    ast = ast.transform(UglifyJS.Compressor());
    ast.figure_out_scope();
    ast.compute_char_frequency();
    ast.mangle_names();
    ast.print(minSrc);

    // Read the source and source map from the uglify pipeline
    src = minSrc.get() + '\n' + comment + filename + '.map';
    srcMap = convert.fromJSON(minMap.toString());

    // Add all the sources and inline them into the source map
    // UglifyJS drops all but the first source file
    sources = Object.keys(sourcesSeen).sort(function (a, b) {
      return (sourcesSeen[a] - sourcesSeen[b]);
    });
    sourcesContent = sources.map(function (source) {
      return sourcesContent[source];
    });
    srcMap.setProperty('sources', sources);
    srcMap.setProperty('sourcesContent', sourcesContent);

    // Write the bundled output
    console.log('Writing ', 'pkg/' + filename);
    fs.writeFileSync('pkg/' + filename, src);

    // Write the source map output
    console.log('Writing ', 'pkg/' + filename + '.map');
    fs.writeFileSync('pkg/' + filename + '.map', srcMap.toJSON());
  });
}


// A browserify factory that provides connect middleware as a serve() method
exports.browserify = function (options) {
  var bundler = browserify(options);
  var promise = null;

  // Browserify currently b0rks source maps when using the standalone option.
  // Here we strip it and provide the functionality ourselves.
  // Fix submitted: https://github.com/substack/node-browserify/pull/508
  var umdWrap = function (result, name) {
    var src = convert.removeComments(result).slice(1, -3);
    var srcMap = new SourceMapGenerator({file: 'generated.js'});
    var inSrcMap = new SourceMapConsumer(convert.fromSource(result).toObject());
    var sourcesSeen = {};

    // Process the mappings accounting for the UMD prelude line
    inSrcMap.eachMapping(function (mapping) {
      if (sourcesSeen[mapping.source] == undefined) {
        var content = inSrcMap.sourceContentFor(mapping.source);
        srcMap.setSourceContent(mapping.source, content);
        sourcesSeen[mapping.source] = true;
      }
      srcMap.addMapping({
        generated: {
          line: mapping.generatedLine + 1,  // Account for UMD prelude
          column: mapping.generatedColumn
        },
        original: {
          line: mapping.originalLine,
          column: mapping.originalColumn
        },
        name: mapping.name,
        source: mapping.source
      });
    });

    // Join the prelude, source, auto-require, postlude and comment
    src = umd.prelude(name) + 'return ' + src;
    src += '\n(1)' + umd.postlude(name);
    src += '\n' + convert.fromJSON(srcMap.toString()).toComment();
    src += '\n;';
    return src;
  }

  // A function which fulfills a promise of building a bundle.
  // Based on connect-browserify but conforming exactly to the browserify API.
  var bundle = function (options) {
    // Strip the standalone option because we handle it ourselves.
    // See above.
    var standalone = options.standalone;
    options = Object.create(options, {
      standalone: {
        enumerable: false,
        value: undefined
      }
    });

    promise = q.defer();
    bundler.bundle(options, function (err, result) {
      if (err) {
        promise.reject(err);
      } else {
        if (standalone) {
          promise.resolve(umdWrap(result, standalone));
        } else {
          promise.resolve(result);
        }
      }
    });
  }

  return Object.create(bundler, {
    bundle: {
      value: function (options, cb) {
        bundle(options);
        promise.then(function (result) {
          if (cb) {
            cb(null, result);
          }
        }).fail(cb);
      }
    },
    serve: {
      value: function (options) {
        bundle(options);
        watchify(bundler).on('update', function () { bundle(options) })
        return function (req, res, next) {
          res.setHeader('Content-Type', 'application/javascript');
          promise.then(function (result) {
            var src = convert.removeComments(result);
            var srcMap = convert.fromSource(result);
            var sources = srcMap.getProperty('sources');
            var sourcesContent = srcMap.getProperty('sourcesContent');

            // Make the files resolve on the filesystem.
            // They will be editable in a Chrome DevTools workspace mapped
            // at the annotator repository root.

            // Strip absolute path information from the source map sources
            sources = sources.map(function (source) {
              return '/' + path.relative(process.cwd(), source);
            });

            // Add all the sources and set the root relative to the workspace
            srcMap.setProperty('sources', sources);

            res.write(src.slice(0,-2));
            res.write(srcMap.toComment());
            res.end('\n;');
          }).fail(next);
        }
      }
    }
  });
};

// The core Annotator bundle
exports.core = exports.browserify({
  entries: ['./src/annotator.coffee'],
  extensions: ['.coffee']
});
exports.core.transform(coffeeify);

// The plugin bundles
exports.plugin = {};
glob.sync('./src/plugin/*.coffee').map(function (pluginSrc) {
  var pluginName = path.basename(pluginSrc).replace('.coffee', '');
  exports.plugin[pluginName] = exports.browserify({
    entries: [pluginSrc],
    extensions: ['.coffee']
  });
  exports.plugin[pluginName].transform(coffeeify);
});


// Package the bundles when called as the main script
if (require.main === module) {
  child_process.exec('./tools/preamble', function (err, preambleSrc) {
    if (err) throw new Error(err);

    var preamble = coffee.compile(preambleSrc, {bare: true}).trim();

    pack(exports.core, 'annotator.js', preamble, {
      debug: true,
      standalone: 'Annotator'
    });

    Object.keys(exports.plugin).forEach(function (name) {
      var filename = 'annotator.' + name + '.js';
      pack(exports.plugin[name], filename, preamble, {debug: true});
    });

    var css = fs.createWriteStream('pkg/annotator.min.css');
    var dataURI = child_process.spawn('./tools/data_uri_ify');

    fs.createReadStream('./css/annotator.css').pipe(dataURI.stdin)

    var cssInput = '';
    dataURI.stdout.on('data', function (data) {cssInput += data});
    dataURI.stdout.on('end', function() {
      var cssOutput = UglifyCSS.processString(cssInput);
      console.log('Writing ', 'pkg/annotator.min.css');
      fs.writeFileSync('pkg/annotator.min.css', preamble + cssOutput);
    });
  });
}
